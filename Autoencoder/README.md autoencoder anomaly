# üß†üö®SUSNATA's Autoencoder-based anomaly detection for credit card transactions  
**unsupervised reconstruction-error model for detecting abnormal spending patterns**

this project applies a deep autoencoder trained **only on normal transactions** to identify anomalies based on reconstruction error.  
since the data is already **pca-transformed and scaled**, the autoencoder focuses purely on **pattern learning**.

---

## üìÇ **1. dataset loading**
```python
import pandas as pd
import numpy as np

path = "/content/drive/MyDrive/creditcardAutoencoder.csv"
df = pd.read_csv(path)
df.head()
```

---

## üßπ **2. preprocessing**

### üîß dropping unused columns  
```python
X = df.drop(["Class","Time","Amount"], axis=1).values
y = df["Class"].values
```

### üîÑ train‚Äìtest split  
```python
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)
```

### üü¢ using only normal data for training  
```python
X_train_normal = X_train[y_train == 0]
```

---

## üèóÔ∏è **3. autoencoder architecture**
```python
from tensorflow.keras import layers, models

input_dim = X_train.shape[1]
encoding_dim = 14
bottleneck = 7

encoder = models.Sequential([
    layers.Input(shape=(input_dim,)),
    layers.Dense(encoding_dim, activation="relu"),
    layers.Dense(bottleneck, activation="relu")
])

decoder = models.Sequential([
    layers.Dense(encoding_dim, activation="relu"),
    layers.Dense(input_dim, activation="sigmoid")
])

inputs = layers.Input(shape=(input_dim,))
encoded = encoder(inputs)
decoded = decoder(encoded)

autoencoder = models.Model(inputs, decoded)
autoencoder.compile(optimizer="adam", loss="mse")
autoencoder.summary()
```

---

## üèãÔ∏è **4. training the model**
```python
history = autoencoder.fit(
    X_train_normal,
    X_train_normal,
    epochs=20,
    batch_size=256,
    validation_split=0.2,
    shuffle=True
)
```

---

## üìâ **5. reconstruction error computation**

### training mse  
```python
recon_train = autoencoder.predict(X_train_normal)
train_mse = np.mean((X_train_normal - recon_train)**2, axis=1)
```

### test mse  
```python
recon_test = autoencoder.predict(X_test)
test_mse = np.mean((X_test - recon_test)**2, axis=1)
```

---

## üéöÔ∏è **6. anomaly threshold selection**
we use the **95th percentile** of training mse as the anomaly cutoff.

```python
threshold_95 = np.percentile(train_mse, 95)
print(threshold_95)
```

---

## üö® **7. anomaly detection**
```python
anomalies = test_mse > threshold_95
print(anomalies.sum())
```

---

## üìä **8. evaluation using true labels**
even though the model is unsupervised, we compare performance with actual fraud labels.

```python
from sklearn.metrics import confusion_matrix, classification_report

cm = confusion_matrix(y_test, anomalies)
print(cm)

print(classification_report(y_test, anomalies, digits=4))
```

**‚ú® highlight:**  
- high recall on fraud class  
- reconstruction-error models are ideal when fraud patterns are rare and unpredictable  

---

## üíæ **9. saving the trained model**
```python
autoencoder.save("/content/drive/MyDrive/final_autoencoder_model.h5")
```

---

## üì§ **10. exporting detected anomalies**
```python
anomalies_df = pd.DataFrame(
    X_test[anomalies],
    columns=df.drop(["Class","Time","Amount"], axis=1).columns
)

anomalies_df["True_Class"] = y_test[anomalies]
anomalies_df.to_csv("/content/drive/MyDrive/detected_anomalies.csv", index=False)
```

---

## üß™ **11. inference example**
```python
from tensorflow.keras.models import load_model
import numpy as np

autoencoder = load_model("/content/drive/MyDrive/final_autoencoder_model.h5", compile=False)

new_data = np.random.randn(5, 28)
recon = autoencoder.predict(new_data)

mse = np.mean((new_data - recon)**2, axis=1)
anomalies = mse > threshold_95
print(anomalies)
```

---

# ‚≠ê summary  
- completely **unsupervised autoencoder**  
- learns **normal credit card transaction signals**  
- fraud appears as **high reconstruction error**  
- simple and effective for **rare anomaly detection**  
- easy to deploy and extend